# Lang-Libraries-Cpp

这个算法还处于实验阶段，作者本人目前只能确定它在理论上可以在某个极限下无限压缩数据。  
如有错误，还请多多指出，谢谢。  

-------

这个算法基于以下几个定理：  
1.当小进制数字向大进制转换时，其表示的数字位数一定小于等于原数字的位数。  
Eg. `8进制的(123456)
-->
16进制的(A72E)`   
2.大进制的数字，最低可以以这些数中的最大数加一作为进制，而能保证其原信息仍能表示。  
Eg. `16进制的(123456)，最低可以以7进制表示而不失去其原本的信息`   
3.大进制的数字，不可以取比其中任何一位数小的数字作为进制，否则会丢失原本的信息。  
4.结合1和2定理，先取最大数加一作为进制，再以此进制向大进制转换，数字肯定会有缩小(位数不一定会缩小)。  
5.当2定理遇到了大进制中的最大数时(如256进制中的255)，说明信道已满，在此状态下无法压缩。  

-------

此测试算法以C++写成，最低需求编译器支持C++14。  
此算法以256个字节为一个块，以一字节所对应的进制——256进制作为大进制，而选择其一半的128进制作为小进制。  
针对超出127的字节，我还设计了flag位，如果有超出就将其减到128以下，使得数据得以进行压缩。  
该算法仅循环一次是没有多大效果的，循环次数越多，压缩效果越明显。  

-------

对于添加flag位是否会产生冗余数据的情况，本人已作过计算。  
长度为256的数据，先经过flag位净化使得符合要求，暂时多出16位；考虑最坏情况，所有净化后的数据每个字节都是最大的(7F)，得到的压缩后长度为240字节，加上多出的16位flag位为256位。这是最坏情况。
数据范围(使用十六进制)在(0,60^256]内的，压缩后数据大小为218字节，加flag长度为234字节。  
以目前这种结果来看，这种算法最坏情况也没有增大数据大小，更多的是有一定的压缩能力。
